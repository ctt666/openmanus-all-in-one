let currentEventSource = null;
let aiMessageDiv = null;
let finalAnswer = null;
let thoughtQuote = null;
let chatMessages = null;
let chat_state = 'none';
// 添加聊天历史记录变量
let chatHistory = [];
let currentSessionId = null;
// 新增：当前模式（chat | flow），默认 chat
let currentMode = 'chat';
// 修改：简化交互相关变量，只保留必要的
let _currentInteractionTaskId = null;

// 新增：全局ask_human状态管理，防止重复处理
let globalAskHumanProcessed = false;
let globalProcessedInquire = null;
let globalProcessedTaskId = null;
// 注释掉：不再需要的交互提示相关变量
/*
let currentInteractionPrompt = null;
let interactionPromptArea = null;
let interactionPromptContent = null;
let interactionInput = null;
let submitInteractionBtn = null;
*/

// 添加加载会话历史的函数
function loadSessionHistory(sessionId) {
    if (!sessionId) return;

    fetch(`/sessions/${sessionId}/history`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to load session history');
            }
            return response.json();
        })
        .then(history => {
            // 清空当前显示
            chatMessages.innerHTML = '';
            chatHistory = [];

            // 重建聊天历史
            history.forEach(task => {
                if (task.chat_history && task.chat_history.length > 0) {
                    task.chat_history.forEach(msg => {
                        addMessage(msg.content, msg.role);
                    });
                }
            });

            currentSessionId = sessionId;
        })
        .catch(error => {
            console.error('Failed to load session history:', error);
            showErrorToast('Failed to load session history');
        });
}

// 注释掉：不再需要的交互提示相关函数
/*
// 新增：初始化交互提示元素
function initializeInteractionElements() {
    interactionPromptArea = document.getElementById('interactionPromptArea');
    interactionPromptContent = document.getElementById('interactionPromptContent');
    interactionInput = document.getElementById('interactionInput');
    submitInteractionBtn = document.getElementById('submitInteractionBtn');

    if (submitInteractionBtn) {
        submitInteractionBtn.addEventListener('click', handleInteractionSubmit);
    }

    if (interactionInput) {
        interactionInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                handleInteractionSubmit();
            }
        });
    }
}

// 新增：显示交互提示
function showInteractionPrompt(prompt, taskId) {
    if (!interactionPromptArea || !interactionPromptContent) {
        console.error('交互提示元素未初始化');
        return;
    }

    currentInteractionPrompt = prompt;
    currentInteractionTaskId = taskId;

    interactionPromptContent.textContent = prompt;
    interactionPromptArea.style.display = 'block';

    // 聚焦到输入框
    if (interactionInput) {
        interactionInput.focus();
    }

    // 滚动到交互提示区域
    interactionPromptArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

// 新增：隐藏交互提示
function hideInteractionPrompt() {
    if (interactionPromptArea) {
        interactionPromptArea.style.display = 'none';
    }

    // 清空输入
    if (interactionInput) {
        interactionInput.value = '';
    }

    currentInteractionPrompt = null;
    currentInteractionTaskId = null;
}

// 新增：处理交互提交
async function handleInteractionSubmit() {
    if (!currentInteractionTaskId || !interactionInput) {
        return;
    }

    const userResponse = interactionInput.value.trim();
    if (!userResponse) {
        showErrorToast('请输入您的回答');
        return;
    }

    try {
        // 发送用户回答到后端
        const response = await fetch(`/tasks/${currentInteractionTaskId}/interact`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                response: userResponse
            })
        });

        if (!response.ok) {
            throw new Error('提交回答失败');
        }

        // 隐藏交互提示
        hideInteractionPrompt();

        // 显示用户回答
        addMessage(userResponse, 'user');
        chatHistory.push({
            role: 'user',
            content: userResponse,
            timestamp: new Date().toISOString()
        });

        // 显示成功提示
        showErrorToast('回答已提交，继续处理中...');

    } catch (error) {
        console.error('提交交互回答失败:', error);
        showErrorToast('提交回答失败: ' + error.message);
    }
}
*/

// 新增：处理ask_human的用户回答
async function handleAskHumanResponse(userResponse) {
    if (!window.currentInteractionTaskId) {
        return;
    }

    try {
        // 显示用户回答
        addMessage(userResponse, 'user');
        chatHistory.push({
            role: 'user',
            content: userResponse,
            timestamp: new Date().toISOString()
        });

        // 发送用户回答到后端
        const response = await fetch(`/tasks/${window.currentInteractionTaskId}/interact`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                response: userResponse
            })
        });

        if (!response.ok) {
            throw new Error('提交回答失败');
        }

        // 保存当前任务ID，然后清除交互状态
        const taskId = window.currentInteractionTaskId;
        window.currentInteractionTaskId = null;

        // 新增：重置ask_human状态，允许后续的ask_human交互
        globalAskHumanProcessed = false;
        globalProcessedInquire = null;
        console.log('Ask_human state reset, ready for next interaction');

        // 显示成功提示
        showErrorToast('回答已提交，继续处理中...');

        // 重新建立SSE连接继续接收后续事件
        const isLongThought = document.getElementById('longThoughtCheckbox').checked;
        setupSSE(taskId, isLongThought);

    } catch (error) {
        console.error('提交ask_human回答失败:', error);
        showErrorToast('提交回答失败: ' + error.message);
    }
}

function getMarkedText(text) {
    return DOMPurify.sanitize(marked.parse(text))
}

function showErrorToast(message) {
    const toastEl = document.getElementById('errorToast');
    const toastBody = toastEl.querySelector('.toast-body');
    toastBody.textContent = message;

    const toast = new bootstrap.Toast(toastEl);
    toast.show();
}

function toggle_chat_state(state) {
    chat_state = state;
    const sendButton = document.getElementById('sendButton');
    const sendSpinner = document.getElementById('send-spinner');
    const sendIcon = sendButton.querySelector('.bi-send');
    const terminateIcon = sendButton.querySelector('.bi-stop-fill');

    if (state === 'working') {
        // 处理中状态：显示terminate按钮
        sendSpinner.style.display = 'inline-block';
        sendIcon.style.display = 'none';
        if (terminateIcon) {
            terminateIcon.style.display = 'inline-block';
        } else {
            // 如果没有terminate图标，创建一个
            const newTerminateIcon = document.createElement('i');
            newTerminateIcon.className = 'bi bi-stop-fill';
            newTerminateIcon.style.display = 'inline-block';
            sendButton.appendChild(newTerminateIcon);
        }
        sendButton.setAttribute('data-bs-title', 'Terminate');
        sendButton.onclick = terminateCurrentTask;
    } else {
        // 非处理中状态：显示send按钮
        sendSpinner.style.display = 'none';
        sendIcon.style.display = 'inline-block';
        if (terminateIcon) {
            terminateIcon.style.display = 'none';
        }
        sendButton.setAttribute('data-bs-title', 'Send to Manus');
        sendButton.onclick = sendMessage;
    }
}

// 新增：终止当前任务
async function terminateCurrentTask() {
    if (!currentEventSource) {
        console.log('没有正在运行的任务');
        return;
    }

    try {
        // 获取当前任务ID（从EventSource URL中提取）
        const eventSourceUrl = currentEventSource.url;
        const taskIdMatch = eventSourceUrl.match(/\/tasks\/([^\/]+)\/events/);
        if (!taskIdMatch) {
            console.error('无法从EventSource URL中提取任务ID');
            return;
        }
        const taskId = taskIdMatch[1];

        console.log(`正在终止任务: ${taskId}`);

        // 发送终止请求到后端
        const response = await fetch(`/tasks/${taskId}/terminate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error('终止任务失败');
        }

        // 关闭EventSource连接
        if (currentEventSource) {
            currentEventSource.close();
            currentEventSource = null;
        }

        // 重置状态
        toggle_chat_state('none');

        // 显示终止成功消息
        addMessage('任务已终止', 'system');
        showErrorToast('任务已成功终止');

    } catch (error) {
        console.error('终止任务失败:', error);
        showErrorToast('终止任务失败: ' + error.message);
    }
}

function createChat() {
    const isLongThought = document.getElementById('longThoughtCheckbox').checked;
    const promptInput = document.getElementById('messageInput');
    const prompt = promptInput.value.trim();

    if (!prompt) {
        showErrorToast("Please enter a valid prompt");
        promptInput.focus();
        return;
    }

    if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
    }

    // 生成或使用现有会话ID
    if (!currentSessionId) {
        currentSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // 构建请求数据，包含聊天历史
    const requestData = {
        prompt: prompt,
        session_id: currentSessionId,
        chat_history: chatHistory
    };

    fetch('/tasks', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => { throw new Error(err.detail || 'Request failed') });
            }
            return response.json();
        })
        .then(data => {
            if (!data.task_id) {
                throw new Error('Invalid task ID');
            }
            addMessage(prompt, 'user');
            // 设置处理中状态，显示terminate按钮
            toggle_chat_state('working');
            setupSSE(data.task_id, isLongThought);
            promptInput.value = '';
        })
        .catch(error => {
            showErrorToast(error.message)
            console.error('Failed to create task:', error);
        });
}

function setupSSE(taskId, isLongThought) {
    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 2000;
    let lastResultContent = '';

    // 修复：使用全局状态管理，防止重复处理
    // 检查是否是新的任务ID，如果是则重置状态
    if (globalProcessedTaskId !== taskId) {
        globalAskHumanProcessed = false;
        globalProcessedInquire = null;
        globalProcessedTaskId = taskId;
        console.log('New task detected, resetting ask_human state');
    }

    function connect() {
        const eventSource = new EventSource(`/tasks/${td}/events`);
        currentEventSource = eventSource;

        // 如果是长思考模式，预先创建AI消息容器
        if (isLongThought) {
            createLongThought('正在处理您的请求...');
        }

        const handleEvent = (event, type) => {
            try {
                const data = JSON.parse(event.data);

                // 新增：调试日志
                console.log(`Received ${type} event:`, data);

                // 统一处理ask_human交互逻辑
                function processAskHuman(inquire, taskId) {
                    // 检查是否已经处理过相同的询问内容
                    if (globalAskHumanProcessed && globalProcessedInquire === inquire && globalProcessedTaskId === taskId) {
                        console.log('Duplicate ask_human detected, skipping:', inquire);
                        return;
                    }

                    console.log('Processing ask_human interaction:', inquire);
                    addMessage(inquire, 'ai');
                    window.currentInteractionTaskId = taskId;
                    toggle_chat_state('none');
                    globalAskHumanProcessed = true;
                    globalProcessedInquire = inquire; // 记录已处理的内容
                    globalProcessedTaskId = taskId; // 记录已处理的任务ID
                }

                // 检测并处理ask_human交互 - 使用优先级顺序，避免重复处理
                if (data.result && typeof data.result === 'string' && !globalAskHumanProcessed) {
                    let inquire = null;
                    let detected = false;

                    // 优先级1：检测ask_human工具执行完成的情况（最高优先级）
                    if (data.result.includes('Tool \'ask_human\' completed its mission!')) {
                        console.log('Detected ask_human tool completion');
                        const interactionMatch = data.result.match(/INTERACTION_REQUIRED:\s*(.+)/);
                        if (interactionMatch) {
                            inquire = interactionMatch[1].trim();
                            detected = true;
                        }
                    }

                    // 优先级2：检测直接的INTERACTION_REQUIRED标记
                    else if (data.result.includes('INTERACTION_REQUIRED:')) {
                        console.log('Detected INTERACTION_REQUIRED in result');
                        inquire = data.result.replace(/.*INTERACTION_REQUIRED:\s*/, '').trim();
                        detected = true;
                    }

                    /的使用（仅在tool类型事件中）
                    else if (type === 'tool' && data.result.includes('ask_human')) {
                    console.log('Detected ask_human tool usage');

                    // 从JSON格式的tool arguments中提取
                    const toolArgsMatch = data.result.match(/Tool arguments: ({[^}]+})/);
                    if (toolArgsM                try {
                        const toolArgs = JSON.parse(toolArgsMatch[1]);
                        if (toolArgs.inquire) {
                            inquire = toolArgs.inquir               detected = true;
                        }
                    } catch (e) {
                        console.log('Failed to parse tool arguments JSON:', e);
                    }
                }

                // 如果JSON解析失败，尝试其他提取方法
                if (!inquire) {
                    const inquireMatch = data.result.match(/inquire["\s]*:["\s]*([^,\n}]+)/);
                    if (inquireMatch) {
                        inquire = inquireMatch[1].replace(/["']/g, '').trim();
                        detected = true;
                    }
                }

                if (!inquire) {
                    const fullInquireMatch = data.result.match(/inquire["\s]*:["\s]*"([^"]+)"/);
                    if (fullInquireMatch) {
                        inquire = fullInquireMatch[1];
                        detected = true;
                    }
                }
            }

                    // 优先级4：检测waiting状态
                    else if (type === 'waiting' && data.result.includes('Waiting for human response')) {
            const inquireMatch = data.result.match(/Waiting for human response to: (.+)/);
            if (inquireMatch) {
                inquire = inquireMatch[1].trim();
                detected = true;
            }
        }
        // 优先级5：检测interaction事件类型
        else if (type === 'interaction' && data.result.includes('Human interaction required:')) {
            inquire = data.result.replace('Human interaction required:', '').trim();
            detected = true;
        }

        // 如果检测到ask_human，处理它
        if (detected && inquire) {
            processAskHuman(inquire, taskId);
            return; // 处理完成后直接返回，避免后续处理
        }
    }

    // 如果已经处理了ask_human，跳过其他处理逻辑
    if (globalAskHumanProcessed) {
        console.log('Ask_human already processed, skipping other logic');
        return;
    }

    if (!isLongThought) {
        if (type === 'act') {
            addMessage(data.result, 'ai')
        }
        return;
    }

    if (type === 'log' && data.result.indexOf('Executing step') > -1) {
        // 如果还没有创建长思考容器，现在创建
        if (!thoughtQuote) {
            createLongThought(data.result);
        } else {
            // 更新现有的思考内容
            const stepDiv = document.createElement('div');
            stepDiv.className = 'thinking-message';
            stepDiv.textContent = data.result;
            thoughtQuote.querySelector('.quote-content').appendChild(stepDiv);
        }
    } else if (type === 'act') {
        if (finalAnswer) {
            finalAnswer.textContent = data.result;
        }
    } el
} catch (e) {
    console.error(`Error handling ${type} event:`, e);
}
        };

const eventTypes = ['think', 'tool', 'act', 'log', 'run', 'message', 'interaction'];
eventTypes.forEach(type => {
    eventSource.addEventListener(type, (event) => handleEvent(event, type));
});

eventSource.addEventListener('complete', (event) => {
    try {
        const data = JSON.parse(event.data);
        lastResultContent = data.result || '';

        // 新增：在任务完成时，如果有交互提示，发送用户回答
        if (window.currentInteractionTaskId === taskId) {
            // 自动发送一个默认回答或提示用户
            console.log('任务完成，但仍有待处理的交互提示');
        }

        if (lastResultContent) {
            if (isLongThought) {
                if (finalAnswer) {
                    finalAnswer.innerHTML = getMarkedText(lastResultContent);
                } else {
                    // 如果没有finalAnswer，创建一个简单的AI消息
                    addMessage(lastResultContent, 'ai');
                }
                // 将最终答案添加到聊天历史
                chatHistory.push({
                    role: 'ai',
                    content: lastResultContent,
                    timestamp: new Date().toISOString()
                });
            } else {
                addMessage(lastResultContent, 'ai');
            }
            // console.log(lastResultContent);
        }
        scrollView();
        eventSource.close();
        currentEventSource = null;
    } catch (e) {
        console.error('Error handling complete event:', e);
    }
    toggle_chat_state('none');
});

// 新增：处理任务终止事件
eventSource.addEventListener('terminated', (event) => {
    try {
        const data = JSON.parse(event.data);
        console.log('任务被终止:', data.message);
        addMessage('任务已终止', 'system');
        eventSource.close();
        currentEventSource = null;
    } catch (e) {
        console.error('Error handling terminated event:', e);
    }
    toggle_chat_state('none');
});

eventSource.addEventListener('error', (event) => {
    try {
        console.error(event)
        const data = JSON.parse(event.data);
        showErrorToast(data.message)
        eventSource.close();
        currentEventSource = null;
        toggle_chat_state('none');
    } catch (e) {
        console.error('Error handling failed:', e);
    }
    toggle_chat_state('none');
});

eventSource.onerror = (err) => {
    if (eventSource.readyState === EventSource.CLOSED) return;

    console.error('SSE connection error:', err);
    eventSource.close();

    fetch(`/tasks/${taskId}`)
        .then(response => response.json())
        .then(task => {
            if (task.status === 'completed' || task.status === 'failed' || task.status === 'terminated') {
                if (task.status === 'completed') {
                    // TODO
                } else if (task.status === 'terminated') {
                    console.log('任务已终止');
                    addMessage('任务已终止', 'system');
                } else {
                    console.error(task)
                    showErrorToast(task.error)
                }
                toggle_chat_state('none');
            } else if (retryCount < maxRetries) {
                retryCount++;
                showErrorToast(`Connection lost, retrying in ${retryDelay / 1000} seconds (${retryCount}/${maxRetries})`)
                setTimeout(connect, retryDelay);
            } else {
                showErrorToast('Connection lost, please try refreshing the page')
                toggle_chat_state('none');
            }
        })
        .catch(error => {
            console.error('Task status check failed:', error);
            if (retryCount < maxRetries) {
                retryCount++;
                setTimeout(connect, retryDelay);
            } else {
                toggle_chat_state('none');
            }
        });
};
    }

connect();
}

// 新增：Flow 版本的 SSE 订阅
function setupFlowSSE(flowId, isLongThought) {
    let retryCount = 0;
    const maxRetries = 3;
    const retryDelay = 2000;

    function connect() {
        const eventSource = new EventSource(`/flows/${flowId}/events`);
        currentEventSource = eventSource;
        if (isLongThought) {
            createLongThought('正在处理您的请求...');
        }
        const handleEvent = (event, type) => {
            try {
                const data = JSON.parse(event.data);
                if (!isLongThought) {
                    if (type === 'act' || type === 'log') {
                        addMessage(data.result || data.message || '', 'ai');
                    }
                    return;
                }
                const text = data.result || data.message || '';
                if (type === 'think') {
                    if (!thoughtQuote) {
                        createLongThought(text || 'Running flow...');
                    } else {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = 'thinking-message';
                        stepDiv.textContent = text;
                        thoughtQuote.querySelector('.quote-content').appendChild(stepDiv);
                    }
                } else if (type === 'act') {
                    if (finalAnswer) {
                        finalAnswer.textContent = text;
                    }
                }
            } catch (e) {
                console.error(`Error handling flow ${type} event:`, e);
            }
        };

        const eventTypes = ['think', 'tool', 'act', 'log', 'run', 'step', 'message'];
        eventTypes.forEach(type => {
            eventSource.addEventListener(type, (event) => handleEvent(event, type));
        });

        eventSource.addEventListener('complete', (event) => {
            try {
                const data = JSON.parse(event.data);
                const content = data.result || '';
                if (content) {
                    if (isLongThought) {
                        // if (finalAnswer) {
                        //     finalAnswer.innerHTML = getMarkedText(content);
                        // }
                        addMessage(content, 'ai');
                        chatHistory.push({ role: 'ai', content: content, timestamp: new Date().toISOString() });
                    } else {
                        addMessage(content, 'ai');
                    }
                }
            } catch (e) {
                console.error('Error handling flow complete:', e);
            }
            eventSource.close();
            currentEventSource = null;
            toggle_chat_state('none');
        });

        eventSource.addEventListener('error', (event) => {
            try {
                const data = JSON.parse(event.data);
                showErrorToast(data.message || 'Flow failed');
            } catch (e) {
                console.error('Error handling flow error:', e);
            }
            eventSource.close();
            currentEventSource = null;
            toggle_chat_state('none');
        });

        eventSource.onerror = (err) => {
            if (eventSource.readyState === EventSource.CLOSED) return;
            console.error('Flow SSE connection error:', err);
            eventSource.close();
            fetch(`/flows/${flowId}`)
                .then(response => response.json())
                .then(task => {
                    if (task.status === 'completed' || task.status === 'failed') {
                        if (task.status === 'completed') {
                            // ignore
                        } else {
                            showErrorToast(task.error || 'Flow failed');
                        }
                    } else if (retryCount < maxRetries) {
                        retryCount++;
                        showErrorToast(`Connection lost, retrying in ${retryDelay / 1000} seconds (${retryCount}/${maxRetries})`)
                        setTimeout(connect, retryDelay);
                    } else {
                        showErrorToast('Connection lost, please try refreshing the page')
                    }
                })
                .catch(error => {
                    console.error('Flow status check failed:', error);
                    if (retryCount < maxRetries) {
                        retryCount++;
                        setTimeout(connect, retryDelay);
                    }
                });
        };
    }

    connect();
}

// 新增：创建 Flow
function createFlow() {
    const isLongThought = document.getElementById('longThoughtCheckbox').checked;
    const promptInput = document.getElementById('messageInput');
    const prompt = promptInput.value.trim();
    if (!prompt) {
        showErrorToast('Please enter a valid prompt');
        promptInput.focus();
        return;
    }
    if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
    }
    if (!currentSessionId) {
        currentSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    const requestData = { prompt: prompt, session_id: currentSessionId, chat_history: chatHistory };
    fetch('/flows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
    }).then(response => {
        if (!response.ok) {
            return response.json().then(err => { throw new Error(err.detail || 'Request failed') });
        }
        return response.json();
    }).then(data => {
        if (!data.task_id) throw new Error('Invalid flow ID');
        addMessage(prompt, 'user');
        // 设置处理中状态，显示terminate按钮
        toggle_chat_state('working');
        setupFlowSSE(data.task_id, isLongThought);
        promptInput.value = '';
    }).catch(error => {
        showErrorToast(error.message);
        console.error('Failed to create flow:', error);
    });
}

// 新增：设置模式的函数（互斥选择）
function setMode(mode) {
    console.log('setMode 被调用，模式:', mode);
    currentMode = mode;
    const btnChat = document.getElementById('btn-chat');
    const btnFlow = document.getElementById('btn-flow');
    
    console.log('按钮元素:', { btnChat, btnFlow });
    
    if (btnChat && btnFlow) {
        if (mode === 'chat') {
            btnChat.classList.add('active');
            btnFlow.classList.remove('active');
            console.log('Chat 模式设置完成');
        } else {
            btnFlow.classList.add('active');
            btnChat.classList.remove('active');
            console.log('Flow 模式设置完成');
        }
    } else {
        console.error('按钮元素未找到，无法设置模式');
    }
}

function loadHistory() {
    fetch('/tasks')
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`request failure: ${response.status} - ${text.substring(0, 100)}`);
                });
            }
            return response.json();
        })
        .then(tasks => {
            applyHistory(tasks)
        })
        .catch(error => {
            console.error('Failed to load history records:', error);
            showErrorToast(error.message)
        });
}

function applyHistory(tasks) {
    if (!tasks) return;
    const historyModal = new bootstrap.Modal(document.getElementById('historyModal'));
    const historyList = document.getElementById('historyList');

    historyList.innerHTML = '';

    if (tasks.length === 0) {
        historyList.innerHTML = '<li class="list-group-item text-muted">Record not found!</li>';
    } else {
        tasks.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        tasks.forEach(item => {
            const title = item.prompt
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.innerHTML = `
                <div class="fw-bold">${title}</div>
                <small class="text-muted">${new Date(item.created_at).toLocaleString()}</small>
            `;

            li.addEventListener('click', function () {
                // 如果有session_id，加载会话历史
                if (item.session_id) {
                    loadSessionHistory(item.session_id);
                } else {
                    // 兼容旧版本，直接显示单条记录
                    chatMessages.innerHTML = '';
                    addMessage(item.prompt, 'user');
                    item.steps.forEach(step => {
                        if (step.type === 'result') {
                            return;
                        }
                        if (step.type === 'log' && step.result.indexOf('Executing step') > -1) {
                            createLongThought(step.result);
                        } else if (step.type === 'act') {
                            finalAnswer.textContent = step.result
                        } else {
                            const stepDiv = document.createElement('div');
                            stepDiv.className = 'thinking-message';
                            stepDiv.textContent = step.result;
                            thoughtQuote.querySelector('.quote-content').appendChild(stepDiv);
                        }
                    });
                }

                historyModal.hide();
            });

            historyList.appendChild(li);
        });
    }

    historyModal.show();
}

function addMessage(text, sender) {
    // 新增：去重逻辑，防止相同的消息被重复显示
    if (sender === 'ai') {
        // 检查最后一条AI消息是否与当前消息相同
        const lastMessage = chatMessages.querySelector('.ai-message:last-child .message-content');
        if (lastMessage && lastMessage.textContent.trim() === text.trim()) {
            console.log('Duplicate AI message detected, skipping:', text.substring(0, 50) + '...');
            return;
        }
    }

    const messageDiv = document.createElement('div');
    messageDiv.classList.add(sender + '-message');

    const iconDiv = document.createElement('div');
    iconDiv.className = 'message-icon';
    const icon = document.createElement('i');
    icon.className = sender === 'user' ? 'bi bi-person-fill' : 'bi bi-robot';
    iconDiv.appendChild(icon);

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    if (sender === 'user') {
        contentDiv.innerHTML = `
        <div class="user-prompt">${text}</div>
        <button class="copy-btn" onclick="copyMessage(this)" title="Copy">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg>
        </button>
        `;
    } else {
        contentDiv.textContent = text;
    }

    if (sender === 'user') {
        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(iconDiv);
    } else {
        messageDiv.appendChild(iconDiv);
        messageDiv.appendChild(contentDiv);
    }

    chatMessages.appendChild(messageDiv);

    // 添加到聊天历史记录
    chatHistory.push({
        role: sender,
        content: text,
        timestamp: new Date().toISOString()
    });

    scrollView();
}

function scrollView() {
    if (!chatMessages) return
    chatMessages.scrollIntoView({ behavior: "auto", block: "end" })
}

function createLongThought(prompt) {
    console.log('Creating long thought with prompt:', prompt);

    aiMessageDiv = document.createElement('div');
    aiMessageDiv.className = 'message ai-message';

    const iconDiv = document.createElement('div');
    iconDiv.className = 'message-icon';
    const icon = document.createElement('i');
    icon.className = 'bi bi-robot';
    iconDiv.appendChild(icon);

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';

    thoughtQuote = document.createElement('div');
    thoughtQuote.className = 'thought-quote';
    thoughtQuote.innerHTML = `
        <div class="quote-header">
            <span>Thinking...</span>
            <span class="toggle-icon expanded"><i class="bi bi-chevron-down"></i></span>
        </div>
        <div class="quote-content">
            <div class="thinking-message">${getMarkedText(prompt)}</div>
        </div>
    `;

    finalAnswer = document.createElement('div');
    finalAnswer.className = 'ai-final-answer';

    contentDiv.appendChild(thoughtQuote);
    contentDiv.appendChild(finalAnswer);

    aiMessageDiv.appendChild(iconDiv);
    aiMessageDiv.appendChild(contentDiv);

    chatMessages.appendChild(aiMessageDiv);
    scrollView();

    console.log('Long thought created. thoughtQuote:', thoughtQuote, 'finalAnswer:', finalAnswer);

    thoughtQuote.addEventListener('click', function (e) {
        if (e.target.closest('.quote-header')) {
            const isCollapsing = !this.classList.contains('collapsed');
            this.classList.toggle('collapsed');
            const icon = this.querySelector('.toggle-icon');
            icon.innerHTML = isCollapsing ? '<i class="bi bi-chevron-up"></i>' : '<i class="bi bi-chevron-down"></i>';
        }
    });
}

function getCustomCss() {
    return `
        <style>
            .message-content h1, .message-content h2, .message-content h3,
            .message-content h4, .message-content h5, .message-content h6 {
                margin: 10px 0;
                color: #343a40;
            }
            .message-content p {
                margin: 5px 0;
            }
            .message-content ul, .message-content ol {
                margin: 10px 0;
                padding-left: 20px;
            }
            .message-content li {
                margin: 5px 0;
            }
            .message-content a {
                color: #007bff;
                text-decoration: none;
            }
            .message-content a:hover {
                text-decoration: underline;
            }
            .message-content code {
                background-color: #f8f9fa;
                padding: 2px 4px;
                border-radius: 4px;
            }
            .message-content pre {
                background-color: #f8f9fa;
                padding: 10px;
                border-radius: 8px;
                overflow-x: auto;
            }
        </style>
    `;
}

document.addEventListener('DOMContentLoaded', function () {
    // Initialize tooltip
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(tooltipTriggerEl => {
        new bootstrap.Tooltip(tooltipTriggerEl);
    });

    document.getElementById('btn-paperclip').addEventListener('click', function () {
        document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', function (event) {
        const fileInput = event.target;
        const file = event.target.files[0];
        if (file) {
            if (file.type === 'text/plain') {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    document.getElementById('messageInput').value = content;
                    fileInput.value = '';
                };
                reader.readAsText(file);
            } else {
                showErrorToast('Please select a text (.txt) file.');
                document.getElementById('fileInput').value = '';
                document.getElementById('messageInput').value = '';
                fileInput.value = '';
            }
        }
    });

    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    chatMessages = document.getElementById('chatMessages');

    if (!messageInput || !sendButton || !chatMessages) {
        console.error('Required elements not found!');
        return;
    }

    // 新增：初始化交互提示元素
    // initializeInteractionElements(); // 注释掉：不再需要的交互提示相关函数

    // 修复：先设置默认模式，再初始化按钮状态
    setMode('chat'); // 确保默认选中new chat
    toggle_chat_state('none');

    // 获取promptShortcuts元素
    const promptShortcuts = document.querySelectorAll('.prompt-shortcut');

    messageInput.addEventListener('keypress', function (e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    promptShortcuts.forEach(shortcut => {
        shortcut.addEventListener('click', function () {
            messageInput.value = this.textContent;
            messageInput.focus();
        });
    });

    // 修改：New Chat 按钮仅切换模式，不再清空会话
    const btnChat = document.querySelector('.btn-chat');
    if (btnChat) {
        btnChat.addEventListener('click', function () {
            setMode('chat');
        });
    }

    document.querySelector('.btn-history').addEventListener('click', function () {
        loadHistory();
    });
    // 修改：Run Flow 按钮仅切换模式
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) {
        btnFlow.addEventListener('click', function () {
            setMode('flow');
        });
    }

    // 移除重复的默认模式设置，因为已经在上面设置了
    // setMode('chat');
});

// 添加缺失的函数定义
function sendMessage() {
    // 修改：检查是否正在等待ask_human的回答，如果是则允许发送
    if (chat_state !== 'none' && !window.currentInteractionTaskId) {
        showErrorToast('Chat bot still under working, please wait...');
        return;
    }
    const message = messageInput.value.trim();
    if (message) {
        // 检查是否正在等待ask_human的回答
        if (window.currentInteractionTaskId) {
            // 处理ask_human的回答
            handleAskHumanResponse(message);
            messageInput.value = '';
            return;
        }

        toggle_chat_state('');
        if (currentMode === 'chat') {
            createChat();
        } else {
            createFlow();
        }
    }
}

// 新增：更新输入框占位符的函数
function updateInputPlaceholder() {
    if (window.currentInteractionTaskId) {
        messageInput.placeholder = '请输入您的回答...';
    } else {
        messageInput.placeholder = 'Ask Manus...';
    }
}

// 监听currentInteractionTaskId的变化
Object.defineProperty(window, 'currentInteractionTaskId', {
    get: function () {
        return _currentInteractionTaskId;
    },
    set: function (value) {
        _currentInteractionTaskId = value;
        updateInputPlaceholder();
    }
});

// 获取promptShortcuts元素 - 移到DOMContentLoaded事件内部

// 新增：调试函数，显示ask_human的当前状态
function debugAskHumanState() {
    console.log('=== Ask Human State Debug ===');
    console.log('Global Ask Human Processed:', globalAskHumanProcessed);
    console.log('Global Processed Inquire:', globalProcessedInquire);
    console.log('Global Processed Task ID:', globalProcessedTaskId);
    console.log('Current Interaction Task ID:', window.currentInteractionTaskId);
    console.log('Chat State:', chat_state);
    console.log('============================');
}

// 将调试函数暴露到全局作用域，方便在控制台调用
window.debugAskHumanState = debugAskHumanState;

